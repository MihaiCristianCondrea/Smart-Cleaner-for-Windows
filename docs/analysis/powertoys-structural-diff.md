# PowerToys vs. Smart Cleaner structure comparison

## Snapshot sources
- [`docs/analysis/cleaner_tree.txt`](cleaner_tree.txt) captures the Smart Cleaner solution tree (excluding `/inspiration`).
- [`docs/analysis/powertoys_cmdpal_ui_tree.txt`](powertoys_cmdpal_ui_tree.txt) captures the `Microsoft.CmdPal.UI` WinUI module inside PowerToys.

## Key structural gaps

| Area | PowerToys (CmdPal) | Smart Cleaner | Impact |
| --- | --- | --- | --- |
| **MSIX manifest identity** | Leaves the identity's architecture blank so MSBuild stamps the real RID during packaging, and keeps the `$targetentrypoint$` token so WinAppSDK can rewrite the entry point to the generated bootstrapper stub. 【F:inspiration/powetoys/src/modules/cmdpal/Microsoft.CmdPal.UI/Package.appxmanifest†L1-L62】 | Hardcodes `ProcessorArchitecture="neutral"` and `EntryPoint="SmartCleanerForWindows.Shell.App"`. Neutral identities are meant for resource-only packages, and bypassing `$targetentrypoint$` prevents WinAppSDK from pointing MSIX at the correct generated host entry point. 【F:src/SmartCleanerForWindows/Package.appxmanifest†L1-L40】 | Windows quietly refuses to activate the packaged app because the identity does not match the architecture of the compiled binaries and the manifest points at a type that no longer has a generated `WinMain` after we defined `DISABLE_XAML_GENERATED_MAIN`. PowerToys avoids both issues by keeping the template tokens. |
| **Packaging props / asset wiring** | Imports `CmdPal.Branding.props` which (a) selects the correct Appx manifest (dev vs release), (b) links all image assets via MSBuild, and (c) resets `AppxPackageDir` + `OutputPath` before packaging. 【F:docs/analysis/powertoys_cmdpal_ui_tree.txt†L123-L147】【F:inspiration/powetoys/src/modules/cmdpal/Microsoft.CmdPal.UI/CmdPal.Branding.props†L1-L36】 | No equivalent props file; the project never tells MSBuild which manifest to embed nor how to flatten the assets into `AppxManifest`. Everything relies on implicit defaults. 【F:docs/analysis/cleaner_tree.txt†L15-L33】【F:src/SmartCleanerForWindows/SmartCleanerForWindows.csproj†L1-L70】 | Missing props means the MSIX is missing channel-specific metadata (e.g., `Package-Dev.appxmanifest` disables registry virtualization) and the asset folder is not stamped into the manifest the way PowerToys expects, so we diverge from a known-good packaging recipe. |
| **Bootstrap + activation** | `Program.cs` decides whether to redirect to an existing instance and only starts the XAML thread after AppLifecycle has been set up; `App.OnLaunched` fetches `AppInstance` activation arguments before creating the window. 【F:inspiration/powetoys/src/modules/cmdpal/Microsoft.CmdPal.UI/Program.cs†L1-L120】【F:inspiration/powetoys/src/modules/cmdpal/Microsoft.CmdPal.UI/App.xaml.cs†L71-L99】 | `Program.cs` tries to bootstrap the WinAppSDK manually and never calls `AppInstance.GetCurrent().GetActivatedEventArgs()`. As soon as `AppInstance.FindOrRegisterForKey` returns `false`, the process quits — there is no redirection handshake. 【F:src/SmartCleanerForWindows/Program.cs†L1-L84】 | Failing to redirect activation leaves the packaged process with nothing to do when Windows tries to hand over a second activation (double-click, protocol launch, etc.). PowerToys’ implementation keeps the process alive and handles the activation, while ours simply returns, which matches the “Launching App…” then nothing symptom. |
| **Per-build manifest variants** | Ships both `Package.appxmanifest` and `Package-Dev.appxmanifest`, letting CI choose the right one through the branding props. 【F:docs/analysis/powertoys_cmdpal_ui_tree.txt†L227-L228】 | Only a single manifest exists, so there is no way to adjust capabilities or metadata per channel/build flavor. 【F:docs/analysis/cleaner_tree.txt†L126-L133】 | Without the dev manifest we miss desktop6 settings (registry virtualization disabled) and startup/task extensions, so the MSIX produced locally can behave differently from the one that works in PowerToys. |

## Deduction
The two most load-bearing discrepancies are the manifest identity tokens and the activation pipeline. PowerToys deliberately keeps `$targetentrypoint$` in its manifest and never forces `ProcessorArchitecture` so the Windows App SDK tooling can stamp a correct entry point and architecture into the MSIX during build. Our manifest overrides both, meaning the packaged binary advertises itself as a neutral architecture app whose entry point is the XAML `App` type, even though we disabled the generated `WinMain` and replaced it with `Program.Main`. The OS accepts the install but refuses to start the executable — exactly the “no window, no crash” behavior Rider shows. Restoring the template manifest (let MSBuild stamp the architecture and entry point) brings us back in line with PowerToys’ structure and removes that silent activation failure path.

The other structural deltas (missing branding props, single manifest, no activation redirection) explain why our MSIX differs from the working PowerToys package even though the code compiles. Once we adopt the same manifest pipeline and activation flow, we should match the PowerToys launch behavior.
